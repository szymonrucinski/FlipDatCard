import { lazy, useCallback, useContext, useEffect, useRef, useState } from 'react';
import { settings } from './config';
import { streamContext } from './context';
import { isBackend } from './detectBackend';
import { getLoadable, isItReady } from './loadable';
import { useMark } from './marks';
import { es6import } from './utils';
function loadLoadable(loadable, callback) {
    var upd = function () { return callback({}); };
    loadable.loadIfNeeded().then(upd, upd);
}
var WEAK_MAP = new WeakMap();
function executeLoadableEventually(loadable, cb) {
    var tracker = {};
    WEAK_MAP.set(loadable, tracker);
    setTimeout(function () {
        if (WEAK_MAP.get(loadable) === tracker) {
            loadable.reload().then(cb);
        }
    }, 16);
}
export function useLoadable(loadable, options) {
    if (options === void 0) { options = {}; }
    var UID = useContext(streamContext);
    var _a = useState(function () {
        if (options.import !== false) {
            if (options.track !== false) {
                useMark(UID, loadable.mark);
            }
            loadable.loadIfNeeded();
        }
        return {};
    }), forceUpdate = _a[1];
    useEffect(function () {
        if (options.import !== false) {
            if (options.track !== false) {
                useMark(UID, loadable.mark);
            }
            loadLoadable(loadable, forceUpdate);
        }
    }, [loadable, options.import]);
    if (isBackend && !isItReady() && loadable.isLoading()) {
        console.error('react-imported-component: trying to render a component which is not ready. You should `await whenComponentsReady()`?');
    }
    var retry = useCallback(function () {
        if (!loadable) {
            return;
        }
        loadable.reset();
        forceUpdate({});
        loadLoadable(loadable, forceUpdate);
    }, [loadable]);
    if (process.env.NODE_ENV !== 'production') {
        if (isBackend) {
            if (!loadable.done) {
                console.error('react-imported-component: using not resolved loadable. You should `await whenComponentsReady()`.');
            }
        }
    }
    return {
        loadable: loadable,
        retry: retry,
        update: forceUpdate,
    };
}
export function useImported(importer, exportPicker, options) {
    if (exportPicker === void 0) { exportPicker = es6import; }
    if (options === void 0) { options = {}; }
    var topLoadable = useState(getLoadable(importer))[0];
    var postEffectRef = useRef(false);
    var _a = useLoadable(topLoadable, options), loadable = _a.loadable, retry = _a.retry, update = _a.update;
    useEffect(function () {
        if (postEffectRef.current) {
            executeLoadableEventually(loadable, function () { return settings.updateOnReload && update({}); });
        }
        postEffectRef.current = true;
    }, ['hot']);
    if (loadable.error) {
        return {
            error: loadable.error,
            loadable: loadable,
            retry: retry,
        };
    }
    if (loadable.done) {
        return {
            imported: exportPicker(loadable.payload),
            loadable: loadable,
            retry: retry,
        };
    }
    return {
        loading: loadable.isLoading(),
        loadable: loadable,
        retry: retry,
    };
}
export function useLazy(importer) {
    var _a = useState(function () {
        var resolve;
        var reject;
        var promise = new Promise(function (rs, rej) {
            resolve = rs;
            reject = rej;
        });
        return {
            resolve: resolve,
            reject: reject,
            lazyComponent: lazy(function () { return promise; }),
        };
    })[0], resolve = _a.resolve, reject = _a.reject, lazyComponent = _a.lazyComponent;
    var _b = useImported(importer), error = _b.error, imported = _b.imported;
    useEffect(function () {
        if (error) {
            reject(error);
        }
        if (imported) {
            resolve(imported);
        }
    }, [error, imported]);
    return lazyComponent;
}
