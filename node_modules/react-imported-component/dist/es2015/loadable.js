import { assingLoadableMark } from './marks';
import { isBackend } from './detectBackend';
import { settings } from "./config";
import { getPreloaders } from "./preloaders";
var pending = [];
var LOADABLE_WEAK_SIGNATURE = new WeakMap();
var LOADABLE_SIGNATURE = new Map();
var addPending = function (promise) { return pending.push(promise); };
var removeFromPending = function (promise) { return pending = pending.filter(function (a) { return a !== promise; }); };
var trimImport = function (str) { return str.replace(/['"]/g, ''); };
export var importMatch = function (functionString) {
    var markMatches = functionString.match(/`imported_(.*?)_component`/g) || [];
    return markMatches
        .map(function (match) { return match && trimImport((match.match(/`imported_(.*?)_component`/i) || [])[1]); });
};
export var getFunctionSignature = function (fn) { return (String(fn)
    .replace(/(["'])/g, '`')
    .replace(/\/\*([^\*]*)\*\//ig, '')); };
export function toLoadable(firstImportFunction, autoImport) {
    if (autoImport === void 0) { autoImport = true; }
    var importFunction = firstImportFunction;
    var _load = function () { return (Promise.all([
        importFunction()
    ].concat(getPreloaders())).then(function (_a) {
        var result = _a[0];
        return result;
    })); };
    var functionSignature = getFunctionSignature(importFunction);
    var mark = importMatch(functionSignature);
    var resolveResolution;
    var resolution = new Promise(function (r) {
        resolveResolution = r;
    });
    var loadable = {
        mark: mark,
        resolution: resolution,
        done: false,
        ok: false,
        error: null,
        payload: undefined,
        promise: undefined,
        isLoading: function () {
            return !!this.promise && !this.done;
        },
        reset: function () {
            this.done = false;
            this.ok = true;
            this.payload = undefined;
            this.promise = undefined;
        },
        replaceImportFunction: function (newImportFunction) {
            importFunction = newImportFunction;
        },
        then: function (cb, err) {
            if (this.promise) {
                return this.promise.then(cb, err);
            }
            if (err) {
                err();
            }
            return Promise.reject();
        },
        loadIfNeeded: function () {
            if (this.error) {
                this.reset();
            }
            if (!this.promise) {
                this.load();
            }
            return this.promise;
        },
        tryResolveSync: function (then) {
            if (this.done) {
                var result_1 = then(this.payload);
                return {
                    then: function (cb) {
                        cb(result_1);
                        return Promise.resolve(result_1);
                    }
                };
            }
            return this.loadIfNeeded().then(then);
        },
        reload: function () {
            if (this.promise) {
                this.promise = undefined;
                return this.load();
            }
            return Promise.resolve();
        },
        load: function () {
            var _this = this;
            if (!this.promise) {
                var promise_1 = this.promise = _load()
                    .then(function (payload) {
                    _this.done = true;
                    _this.ok = true;
                    _this.payload = payload;
                    _this.error = null;
                    removeFromPending(promise_1);
                    resolveResolution(payload);
                    return payload;
                }, function (err) {
                    _this.done = true;
                    _this.ok = false;
                    _this.error = err;
                    removeFromPending(promise_1);
                    throw err;
                });
                addPending(promise_1);
            }
            return this.promise;
        }
    };
    if (mark && mark.length) {
        LOADABLE_SIGNATURE.set(functionSignature, loadable);
        assingLoadableMark(mark, loadable);
    }
    else {
        console.warn('react-imported-component: no mark found at', importFunction, 'Please check babel plugin or macro setup, as well as imported-component\'s limitations. See https://github.com/theKashey/react-imported-component/issues/147');
    }
    if (isBackend && autoImport) {
        loadable.load();
    }
    return loadable;
}
var readyFlag = false;
export var isItReady = function () { return readyFlag; };
export var done = function () {
    if (pending.length) {
        readyFlag = false;
        return Promise
            .all(pending)
            .then(function (a) { return a[1]; })
            .then(done);
    }
    readyFlag = true;
    return Promise.resolve();
};
export var dryRender = function (renderFunction) {
    renderFunction();
    return Promise
        .resolve()
        .then(done);
};
export var markMeta = [];
var assignMetaData = function (mark, loadable, chunkName, fileName) {
    markMeta.push({ mark: mark, loadable: loadable, chunkName: chunkName, fileName: fileName });
};
export var assignImportedComponents = function (set) {
    var countBefore = LOADABLE_SIGNATURE.size;
    set.forEach(function (imported) {
        var allowAutoLoad = !(imported[3] || !settings.fileFilter(imported[2]));
        var loadable = toLoadable(imported[0], allowAutoLoad);
        assignMetaData(loadable.mark, loadable, imported[1], imported[2]);
    });
    if (countBefore === LOADABLE_SIGNATURE.size) {
        console.error('react-imported-component: no import-marks found, please check babel plugin');
    }
    done();
    return set;
};
export function executeLoadable(importFunction) {
    if ('resolution' in importFunction) {
        return importFunction.reload();
    }
    else {
        return importFunction();
    }
}
export function getLoadable(importFunction) {
    if ('resolution' in importFunction) {
        return importFunction;
    }
    if (LOADABLE_WEAK_SIGNATURE.has(importFunction)) {
        return LOADABLE_WEAK_SIGNATURE.get(importFunction);
    }
    var functionSignature = getFunctionSignature(importFunction);
    if (LOADABLE_SIGNATURE.has(functionSignature)) {
        var loadable_1 = LOADABLE_SIGNATURE.get(functionSignature);
        loadable_1.replaceImportFunction(importFunction);
        return loadable_1;
    }
    var loadable = toLoadable(importFunction);
    LOADABLE_WEAK_SIGNATURE.set(importFunction, loadable);
    return loadable;
}
export var clearImportedCache = function () { return LOADABLE_SIGNATURE.clear(); };
